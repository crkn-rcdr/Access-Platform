import { JSONSchemaType } from "ajv";
import { inherit } from "../validator";
import { Canonical, schema as canonicalSchema } from "./Canonical";
import { Noid, inline as noidSchema } from "../format/noid";
import { FileRef, inline as fileSchema } from "../util/FileRef";
import { Text, inline as textSchema } from "../util/Text";

const FROM = ["canvases", "pdf"];
const BEHAVIORS = ["unordered", "individuals", "continuous", "paged"];
const DIRECTIONS = [
  "left-to-right",
  "right-to-left",
  "top-to-bottom",
  "bottom-to-top",
];

export type Canvas = {
  /**
   * The canvas's Noid.
   */
  id: Noid;

  /**
   * The canvas's label in the context of this manifest.
   */
  label: Text;
};

type ManifestSpec = {
  type: "manifest";

  /**
   * Type of manifest source.
   */
  from: typeof FROM[number];

  /**
   * Semantics about what the order of the series of images means.
   * Default value: `continuous`
   */
  behavior?: typeof BEHAVIORS[number];

  /**
   * Direction the manifest's images are meant to be viewed in.
   * Default value: `left-to-right`
   */
  viewingDirection?: typeof DIRECTIONS[number];

  // The following fields apply to manifests generated from canvases.

  /**
   * The manifest's canvas list. Note: will become mandatory following a migration.
   */
  canvases?: Canvas[];

  /**
   * Information about the derivative PDF generated by OCR.
   * If path is not specified, a file should exist in the
   * access object store at $id.pdf
   */
  ocrPdf?: FileRef;

  // The following fields apply to manifests generated from a born-digital PDF.

  /**
   * Reference to the PDF file this manifest was generated from.
   */
  file?: FileRef;

  /**
   * Labels for this PDF's pages.
   */
  pageLabels?: Text[];
};

/**
 * Any work primarily consisting of a sequence of images.
 */
export type Manifest = Canonical & ManifestSpec;

const specSchema = {
  $id: "/access/Manifest",
  title: "Manifest",
  description: "Any work primarily consisting of a sequence of images.",
  type: "object",
  properties: {
    type: { type: "string", const: "manifest" },
    from: {
      description: "Type of manifest source.",
      type: "string",
      enum: FROM,
    },
    behavior: {
      description:
        "Semantics about what the order of the series of images means.",
      type: "string",
      enum: BEHAVIORS,
      default: "continuous",
      nullable: true,
    },
    viewingDirection: {
      description: "Direction the manifest's images are meant to be viewed in.",
      type: "string",
      enum: DIRECTIONS,
      default: "left-to-right",
      nullable: true,
    },
    canvases: {
      description:
        "The manifest's canvas list. This will become a mandatory property after canvases are generated for PDF manifests.",
      type: "array",
      items: {
        type: "object",
        properties: {
          id: { ...noidSchema, description: "The canvas's Noid." },
          label: {
            ...textSchema,
            description: "The canvas's label in the context of this manifest.",
          },
        },
        required: ["id", "label"],
      },
      nullable: true,
    },
    ocrPdf: {
      ...fileSchema,
      nullable: true,
      description:
        "Information about the derivative PDF generated by OCR. If path is not specified, a file should exist in the access object store at $id.pdf",
    },
    file: {
      ...fileSchema,
      description:
        "Reference to the source PDF this manifest was generated from.",
      nullable: true,
    },
    pageLabels: {
      description:
        "Labels for this PDF's pages. Deprecated in favour of the labels found in the canvases field.",
      type: "array",
      items: textSchema,
      nullable: true,
    },
  },
  required: ["type", "from"],
} as JSONSchemaType<ManifestSpec>;

export const { inline, schema, validate } = inherit<
  Manifest,
  Canonical,
  ManifestSpec
>(canonicalSchema, specSchema, false);
